# Prime Field

Given a odd prime p, the integers {0, 1, ..., p-1} form a finite field Fp.

Operations:

* Addition

```
a + b mod p
```

* Subtraction

```
a - b mod p
```

* Multiplication

```
a * b mod p
```

* Inversion

```
a^-1 mod p
```

# Elliptic Curve

An elliptic curve defined over a prime field Fp with the following equation:

    y^2 = x^3 + a*x + b

Basic parameters:

* p: the prime
* a
* b
* G: the base point
* n: order of the base point G

As for P-256, the parameters are:

```
p = 2^256 - 2^224 + 2^192 + 2^96 - 1
a = p-3
G: x = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
   y = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
```

Curve point: P with coordinates (x, y)
Infinite point: O

**Note**: all the computations below are on field Fp.

## Double Point

**Input** point P1(x1, y1)

**Output** point P2(x2, y2) = [2]P1

If P1 is O, the result is O.

Else, process the following computation.

```
X1 = x1, Y1 = y1, Z1 = 1
S = 4 * X1 * Y1^2
M = 3 * X1^2 + a * Z1^4
X2 = M^2 - 2 * S
Y2 = M * (S - X2) - 8 * Y1^4
Z2 = 2 * Y1 * Z1
x2 = X2 / Z2^2
y2 = Y2 / Z2^3
return (x2, y2)
```


## Point Addition

**Input** two point P1(x1, y1) and P2(x2, y2).

**Output** point P3(x3, y3) = P1 + P2


If P1 is O, then P3 = P2.

If P2 is O, then P3 = P1.

Else, process the following computation.


```
X1 = x1, Y1 = y1, Z1 = 1
X2 = x2, Y2 = y2, Z2 = 1

U1 = X1 * Z2^2
U2 = X2 * Z1^2
S1 = Y1 * Z2^3
S2 = Y2 * Z1^3

if U1 == U2 && S1 != S2:
    return O
else if U1 == U2 && S1 == S2:
    return [2]P1
else:
    H = U2 - U1
    R = S2 - S1
    X3 = R^2 - H^3 - 2 * U1 * H^2
    Y3 = R * (U1 * H^2 - X3) - S1 * H^3
    Z3 = H * Z1 * Z2
    x3 = X3 / Z3^2
    y3 = Y3 / Z3^3
    return (x3, y3)
```


While [2]P is the double point of P, [k]P is the k times point of P. Calculation
of [k]P is the combination of Double Point and Point Addition, for example
[6]P = [2]([2]P + P).


# ECDSA Verification

**Input**

* Public key P(x, y), a point on the curve
* Signed data e, a byte sequence, usually the digest of the original message
  generated by a hash function
* Signature (r, s), a pair of integers in Fp.

**Output**

TRUE or FALSE

**Process**

1. Verify that r, s ∈ [1, n-1]. IF not, return FALSE.
2. w = s^-1 mod n
3. u1 = e*w mod n, u2 = r*w mod n
4. Q(x1, y1) = [u1]G + [u2]P. If Q is the infinite point, return FALSE.
5. If r ≡ x1 mod n, return TRUE. Else return FALSE.


# Optimizations

## Montgomery Multiplication

The prime field multiplication is the most time consuming operation and could
be optimized using Montgomery Multiplication (MM).

Assume `p` is a `l` bits prime, MM can efficiently calculate `a * b * 2^-l mod p`.

```
Input    p, a, b, l = s * k, where s is the unit length for calculation

Output   a * b * 2^-l mod p

Pre-compute k0 = -p^-1 mod 2^s

t = a * b
for i <- 1 to k:
    t1 = t mod 2^s
    u = t1 * k0 mod 2^s
    t2 = u * p
    t3 = t + t2
    t = t3 / 2^s

if t >= p: x = t - p
else: x = p

return x
```

Obviously, the only division operation can be done by bit shifts.

For calculating `a * b mod p`, first transform `a` and `b` to `a'` and `b'`:

```
a' = a * 2^l ≡ a * 2^2l * 2^-l mod p
b' = b * 2^l ≡ b * 2^2l * 2^-l mod p
```

Then calculate 

```
t = a' * b' * 2^-l mod p
a * b ≡ 1 * t * 2^-l mod p
```

Since, MM is complete for the whole calculation.


## Fast Multi-Scalar

The step 4 of ECDSA Verification is the slowest because of the scalar multiplication
of the points which involves plenty of prime field operations. There are several
techniques to accelerate this.

The basic is to calculate the target point with Jacobian projective coordinates.
This avoids the inversion operation of Fp.

### Shamir's Trick

Shamir's trick is a technique to calculate [m]P + [n]Q simultaneously. The general
idea is to represent m and n in binary. For example 145 and 207 has the following
representation:

    145 = (1 0 0 1 0 0 0 1)
    207 = (1 1 0 0 1 1 1 1)

Traverse the two from left to right simultaneously. For each 1 do an addition
to the result and doubling it before going to the next bit.

Obviously this needs l doublings, while the number of additions depends on the
so called Hamming Weight, i.e. the number of non-zero columns.

Signed binary representation is a better form which can reduce the Hamming Weight.
It uses {-1, 0, 1} as the bit values. Following is a representation of 145 and
207 with the Hamming Weight 5:

    145 = (0  1  0  0  1  0  0  0  1)
    207 = (1  0 -1  0  1  0  0  0 -1)

With pre-compiled P+Q and P-Q, it only needs 5 additions.

### Joint Sparse Form

An further impoved method is the Joint Sparse Form (JSF) which generates signed
binary representations from right to left with lower Hamming Weight.

TODO

### Double-base Chains

Traditional representations of integers are single based such as bases 2, 8, 10
and 16. Double-base number system use two bases to represent integers. For example

    n = SUM_i(c_i * 2^a_i * 3^b_i)

This uses 2 and 3 as the double base. 

For all `a_i` and `b_i`, if `a_i >= a_i+1` and `b_i >= b_i+1`, we call the
representation as a Joint Double-Base Chain (JDBC)

Let `v_p(x)` denote the largest exponent of p that satisfies `p^v_p(x)` devids
x. And denote `v_p(x, y) = min(v_p(x), v_p(y))`. To generate a JDBC of m and n,
we can use the following algorithm:

```
i = 0
a_i = v_2(m, n)
b_i = v_3(m, n)
x = m / (2^a_i * 3^b_i)
y = n / (2^a_i * 3^b_i)

while x > 1 or y > 1:
    find the largest g = 2^v_2(x - c_i, y - d_i) * 3^v_3(x - c_i, y - d_i), where c_i, d_i in {-1, 0, 1}
    x = (x - c_i) / g
    y = (y - d_i) / g
    a_i = a_i-1 + v_2(g)
    b_i = b_i-1 + v_3(g)

c_i = x
d_i = y

inverse the sequences [a_i], [b_i], [c_i] and [d_i]
```

The JDBC for m and n are then

    m = SUM_i(c_i * 2^a_i * 3^b_i) for m
    n = SUM_i(d_i * 2^a_i * 3^b_i) for n

For example, the JDBC of 542788 and 462444 have  the following representations:

            a_i  11   9   7   7   5   5   5   4   2
            b_i   5   4   4   3   3   2   1   0   0
    542788  c_i   1   1   0   1   0   1  -1   0   1
    462444  d_i   1  -1   1  -1  -1   1  -1   1  -1

JDBC can further reduce the Hamming Weight, while involves the tripling operation
in the multi-scalar. Following is an algorithm for calculate [m]P + [n]Q with
JDBC:

```
Pre-compute P+Q and P-Q
let l be the length of the JDBC
result = 0
for i <- 0 to l-1:
    if c_i == 1 and d_i == 1:
        result = result + (P+Q)
    else if c_i == -1 and d_i == -1:
        result = result - (P+Q)
    else if c_i == 1 and d_i == -1:
        result = result + (P-Q)
    else if c_i == -1 and d_i == 1:
        result = result - (P-Q)
    else if c_i != 0:
        result = result + c_i * P
    else if d_i != 0:
        result = result + d_i * Q

    for j <- 1 to a_i - a_i+1:
        result = double(result)
    for k <- 1 to b_i - b_i+1:
        result = triple(result)
```

# Further Reading

[1] nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf

[2] https://eprint.iacr.org/2013/816.pdf

[3] http://www.hackersdelight.org/MontgomeryMultiplication.pdf

[4] http://web.science.mq.edu.au/~doche/asilomar.pdf

[5] http://www.ijana.in/papers/V4I2-8.pdf

[6] https://www.iacr.org/archive/eurocrypt2009/54790501/54790501.pdf
